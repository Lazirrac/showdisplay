<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ShowDisplay - Output</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }
    #output-canvas {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    .layer {
      position: absolute;
      display: block;
    }
    .layer-video, .layer-image {
      object-fit: contain;
    }
    .layer-text {
      color: white;
      font-size: 48px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div id="output-canvas"></div>

  <script>
    const { ipcRenderer } = require('electron')
    const canvas = document.getElementById('output-canvas')

    // Listen for scene updates from control window
    ipcRenderer.on('render-scene', (event, sceneData) => {
      renderScene(sceneData)
    })

    function renderScene(scene) {
      // Clear current content
      canvas.innerHTML = ''

      if (!scene || !scene.sources || scene.sources.length === 0) {
        // Show default message when no sources
        const message = document.createElement('div')
        message.style.position = 'absolute'
        message.style.top = '50%'
        message.style.left = '50%'
        message.style.transform = 'translate(-50%, -50%)'
        message.style.color = '#64748b'
        message.style.fontSize = '24px'
        message.style.fontFamily = 'Arial, sans-serif'
        message.style.textAlign = 'center'
        message.textContent = 'No active scene'
        canvas.appendChild(message)
        return
      }

      // Render each source/layer sorted by zIndex
      const sortedSources = [...scene.sources].sort((a, b) => a.zIndex - b.zIndex)

      sortedSources.forEach(source => {
        if (!source.visible) return

        const layer = document.createElement('div')
        layer.className = 'layer'
        layer.style.position = 'absolute'
        layer.style.left = source.x + 'px'
        layer.style.top = source.y + 'px'
        layer.style.width = source.width + 'px'
        layer.style.height = source.height + 'px'
        layer.style.transform = `rotate(${source.rotation}deg)`
        layer.style.zIndex = source.zIndex || 0

        const props = source.properties

        if (source.type === 'video') {
          const video = document.createElement('video')
          video.src = props.src
          video.className = 'layer-video'
          video.style.width = '100%'
          video.style.height = '100%'
          video.style.objectFit = 'contain'
          video.autoplay = true
          video.loop = props.loop || false
          video.volume = (props.volume || 100) / 100
          video.muted = props.muted || false
          layer.appendChild(video)
        } else if (source.type === 'image') {
          layer.style.backgroundImage = `url(${props.src})`
          layer.style.backgroundSize = 'contain'
          layer.style.backgroundPosition = 'center'
          layer.style.backgroundRepeat = 'no-repeat'
        } else if (source.type === 'text') {
          const hexToRgba = (hex, opacity) => {
            const r = parseInt(hex.slice(1, 3), 16)
            const g = parseInt(hex.slice(3, 5), 16)
            const b = parseInt(hex.slice(5, 7), 16)
            return `rgba(${r}, ${g}, ${b}, ${opacity / 100})`
          }

          layer.textContent = props.text || ''
          layer.style.fontSize = (props.fontSize || 48) + 'px'
          layer.style.fontFamily = props.fontFamily || 'Arial'
          layer.style.color = props.color || '#ffffff'
          layer.style.backgroundColor = hexToRgba(props.backgroundColor || '#000000', props.backgroundOpacity || 0)
          layer.style.textAlign = props.textAlign || 'center'
          layer.style.fontWeight = props.bold ? 'bold' : 'normal'
          layer.style.fontStyle = props.italic ? 'italic' : 'normal'
          layer.style.textDecoration = props.underline ? 'underline' : 'none'
          layer.style.display = 'flex'
          layer.style.alignItems = 'center'
          layer.style.justifyContent = props.textAlign === 'center' ? 'center' : props.textAlign === 'right' ? 'flex-end' : 'flex-start'
          layer.style.padding = '8px'
          layer.style.wordWrap = 'break-word'
          layer.style.overflow = 'hidden'
        } else if (source.type === 'timer') {
          const hexToRgba = (hex, opacity) => {
            const r = parseInt(hex.slice(1, 3), 16)
            const g = parseInt(hex.slice(3, 5), 16)
            const b = parseInt(hex.slice(5, 7), 16)
            return `rgba(${r}, ${g}, ${b}, ${opacity / 100})`
          }

          const formatTime = (seconds) => {
            const h = Math.floor(seconds / 3600)
            const m = Math.floor((seconds % 3600) / 60)
            const s = seconds % 60

            if (props.format === 'HH:MM:SS') {
              return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`
            } else if (props.format === 'MM:SS') {
              const totalMinutes = Math.floor(seconds / 60)
              return `${String(totalMinutes).padStart(2, '0')}:${String(s).padStart(2, '0')}`
            } else {
              return String(seconds).padStart(2, '0')
            }
          }

          const displayTime = props.mode === 'clock'
            ? new Date().toLocaleTimeString()
            : props.mode === 'countdown'
            ? formatTime(Math.max(0, props.duration - props.elapsed))
            : formatTime(props.elapsed)

          layer.textContent = displayTime
          layer.style.fontSize = (props.fontSize || 64) + 'px'
          layer.style.fontFamily = props.fontFamily || 'Arial'
          layer.style.color = props.color || '#ffffff'
          layer.style.backgroundColor = hexToRgba(props.backgroundColor || '#000000', props.backgroundOpacity || 0)
          layer.style.display = 'flex'
          layer.style.alignItems = 'center'
          layer.style.justifyContent = 'center'
          layer.style.fontVariantNumeric = 'tabular-nums'
        }

        canvas.appendChild(layer)
      })
    }

    // Initial empty state
    console.log('Output window ready')
  </script>
</body>
</html>
